import TokenContainer from '../token-container';
import { UdtNodeConstructionData } from '../schema';
import UdtNode from '../node';


export default class MockContainer extends TokenContainer<string> {
  static INVALID_KEY = 'invalid-key-for-testing';
  static AUTOGENERATED_KEY_PREFIX = 'child-';
  #autoKeyCounter = 1;

  public doAppendOrSetChildMockFn = jest.fn();
  public doRemoveChildMockFn = jest.fn();
  public keyForMockFn = jest.fn();

  #children: { [key: string]: UdtNode } = {};
  #isFile: boolean;

  constructor(
    data: UdtNodeConstructionData = { name: 'dummy name' },
    isFile = false
  ) {
    super(data);
    this.#isFile = isFile;
  }

  public getChild(key: string) {
    return this.#children[key];
  }

  protected _isFile() {
    return this.#isFile;
  }

  protected _doAppendOrSetChild(child: UdtNode, key?: string) {
    this.doAppendOrSetChildMockFn(child, key);
    if (key === undefined) {
      // Naive implementation that simply uses the child node's name
      // as the new key. A proper one should also ensure that it
      // doesn't clash with an existing key!
      key = child.hasOwnName() ? child.name : this.generateAvailableKey();
    }
    this.#children[key] = child;
    return key;
  }

  protected _doRemoveChild(key: string) {
    this.doRemoveChildMockFn(key);
    const removedNode = this.#children[key];
    delete this.#children[key];
    return removedNode;
  }

  public keyFor(child: UdtNode): string | undefined {
    this.keyForMockFn(child);
    let foundKey: string | undefined = undefined;
    for(let key in this.#children) {
      if (this.#children[key] === child) {
        foundKey = key;
        break;
      }
    }
    return foundKey;
  }

  public get length() {
    return Object.values(this.#children).length;
  }

  public keys() {
    return Object.keys(this.#children)[Symbol.iterator]();
  }

  public [Symbol.iterator]() {
    return Object.values(this.#children)[Symbol.iterator]();
  }

  public generateAvailableKey(): string {
    return MockContainer.AUTOGENERATED_KEY_PREFIX + this.#autoKeyCounter++;
  }

  protected _isValidKeyForSetting(key: string): boolean {
    if (key === MockContainer.INVALID_KEY) {
      return false;
    }
    return true;
  }
}
